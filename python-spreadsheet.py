# SPDX-License-Identifier: MIT

import pandas as pd
import sys

# @brief An array of column labels to compare csv files against.
keep_columns = [
    "SparkFun Part Number",
    "Part Description",
    "BOM Quantity",
    "Primary Vendor",
    "Primary Vendor Part Number",
    "Primary Vendor Cost",
]

# @brief An array of strings to compare csv files against.
exclude_labels = ["FD", "TP", "FID", "SJ", "DNP", "JP"]

# @brief Path fo csv output.
csv_path = "/SparkFun/JLCPCB-Transfer-Eagle-Files/Updated_"

# ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
# ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
# █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
# ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
# ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
# ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝


# @brief Function takes a path to a csv file. It filters out specific columns within csv
# files generated by Sparkle
# @param path_to_spreadsheet Path to the spreadsheet
# @return nothing
def sparkle_assembly_update(path_to_spreadsheet):
    truncated_path = path_to_spreadsheet.split("/")[-1]
    print(f"\nReading from {truncated_path}\n")
    # Insanely powerful ability to both read a csv, keep specific columns, and sort alphabetically
    # from within one function call.
    new_csv = pd.read_csv(path_to_spreadsheet, usecols=keep_columns).sort_values(
        "SparkFun Part Number"
    )
    print(new_csv)
    # Without the "index = False" line there is an extra column added in column "A" listing the index.
    # of the rows.
    print("Placed here: {0}{1}".format(csv_path, truncated_path))
    new_csv.to_csv("~{0}{1}".format(csv_path, truncated_path), index=False)


# @brief Filters out rows for specific labels of BOMS and CPL csv's generated by the Eagle JLCPCB ULP
# @param path_to_spreadsheet Path to the spreadsheet
# @return nothing
def ulp_csv_update(path_to_spreadsheet):
    # Split by path designators and keep the last split which is the file itself.
    truncated_path = path_to_spreadsheet.split("/")[-1]
    print(f"\nReading from {truncated_path}\n")
    # Read in the given cs, can be position or BOM csv.
    csv_pd = pd.read_csv(path_to_spreadsheet)
    # Return a copy of the csv that removes the rows from the column "Designator" that match the labels within
    # "exclude_labels". Note that this is in fact making a csv that match the labels of the list, but inverts the
    # matching behavior: ~
    updated_csv = csv_pd[~csv_pd["Designator"].str.contains("|".join(exclude_labels))]
    alphabetized_csv = updated_csv.sort_values("Designator")
    # Print it so that we can check it at a glance on the terminal
    print(alphabetized_csv)
    # If it's a position file "CPL" output that, otherwise it's a BOM
    if "cpl" in path_to_spreadsheet:
        print("Placed here: {0}{1}".format(csv_path, truncated_path))
        alphabetized_csv.to_csv("~{0}{1}".format(csv_path, truncated_path), index=False)
    else:
        print("Placed here: {0}{1}".format(csv_path, truncated_path))
        alphabetized_csv.to_csv("~{0}{1}".format(csv_path, truncated_path), index=False)


#
# ███╗   ███╗ █████╗ ██╗███╗   ██╗
# ████╗ ████║██╔══██╗██║████╗  ██║
# ██╔████╔██║███████║██║██╔██╗ ██║
# ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
# ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
# ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
#
if __name__ == "__main__":
    path_to_spreadsheet = sys.argv[1]
    if sys.argv[2] == "0":
        sparkle_assembly_update(path_to_spreadsheet)
    elif sys.argv[2] == "1":
        ulp_csv_update(path_to_spreadsheet)
    else:
        print("Choose between 0 and 1")
        print("0 = Sparkle BOM")
        print("1 = Eagle JLCPCB ULP BOM and CPL")
        sys.exit(1)
