# SPDX-License-Identifier: MIT

import pandas as pd
import sys

# @brief An array of column labels to compare csv files against.
keep_columns = [
    "SparkFun Part Number",
    "Part Description",
    "BOM Quantity",
    "Primary Vendor",
    "Primary Vendor Part Number",
    "Primary Vendor Cost",
    "Alternate Manufacturer",
    "Alternate Manufactuerer Part Number",
]

# @brief An array of strings to compare csv files against.
remove_rows = ["FD", "TP"]


# ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
# ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
# █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
# ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
# ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
# ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝


# @brief Function takes a path to a csv file. It filters out specific columns within csv
# files generated by Sparkle
# @param path_to_spreadsheet Path to the spreadsheet
# @return nothing
def sparkle_assembly_update(path_to_spreadsheet):
    truncated_path = path_to_spreadsheet.split("/")[-1]
    print(f"\nReading from {truncated_path}\n")
    # Insanely powerful ability to both read a csv and keep specific columns from it within one function call.
    new_csv = pd.read_csv(path_to_spreadsheet, usecols=keep_columns)
    # Without the "index = False" line there is an extra column added in column "A" listing the index.
    # of the rows.
    new_csv.to_csv("Updated_Sparkle_BOM.csv", index=False)


# @brief Filters out rows for specific labels of BOMS and CPL csv's generated by the Eagle JLCPCB ULP
# @param path_to_spreadsheet Path to the spreadsheet
# @return nothing
def ulp_csv_update(path_to_spreadsheet):
    # Split by path designators and keep the last split which is the file itself.
    truncated_path = path_to_spreadsheet.split("/")[-1]
    print(f"\nReading from {truncated_path}\n")
    # Read in the given cs, can be position or BOM csv.
    csv_pd = pd.read_csv(path_to_spreadsheet)
    # In the "Designator" column, check rows for passed strings.
    # Those are ignored (!) and the rest is saved.
    swapped_csv = csv_pd[
        ~csv_pd["Designator"].str.contains(remove_rows[0])
        & ~csv_pd["Designator"].str.contains(remove_rows[1])
    ]
    # Print it so that we can check it at a glance on the terminal
    print(swapped_csv)
    # If it's a position file "CPL" output that, otherwise it's a BOM
    if "cpl" in path_to_spreadsheet:
        print("Updated_JLCPCB_CPL.csv")
        swapped_csv.to_csv("Updated_JLCPCB_CPL.csv")
    else:
        print("Updated_JLCPCB_BOM.csv")
        swapped_csv.to_csv("Updated_JLCPCB_BOM.csv")


#
# ███╗   ███╗ █████╗ ██╗███╗   ██╗
# ████╗ ████║██╔══██╗██║████╗  ██║
# ██╔████╔██║███████║██║██╔██╗ ██║
# ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
# ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
# ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
#
if __name__ == "__main__":
    path_to_spreadsheet = sys.argv[1]
    if sys.argv[2] == "0":
        sparkle_assembly_update(path_to_spreadsheet)
    if sys.argv[2] == "1":
        ulp_csv_update(path_to_spreadsheet)
